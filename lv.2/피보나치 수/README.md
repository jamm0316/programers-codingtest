## pseudo code
### case 1. 재귀함수
1. magic_number 상수로 지정
2. 재귀 함수 정의
  - 인자 3개 설정(i, j, count)
  - if count === n일 때, i % magic 리턴
  - else recursive(j, i+j, count + 1) 재귀호출
3. 재귀함수 초기화
  - return recusive(0, 1, 0)
#### 오류
1. 큰 수 대입 시 stack overflow 발생
2. 런타임 에러 발생
---
### case 2. for 함수
1. magic number 상수로 정의
2. a = 0, b = 1, temp = 0으로 초기화
3. for (i = 2; i <= n; i++)
  - temp = (a + b) % magic
  - a = b, b = temp로 각각 바인딩
4. return temp로 나머지 반환
---
### case 3. 매트릭스 이용
위 코드에서 매 단계마다 나머지를 계산하기 때문에, n이 큰 경우에도 올바른 결과를 반환할 수 있습니다. 하지만 코드의 시간 복잡도는 O(n)이므로, n=12345678n과 같은 큰 값에 대해 성능이 떨어질 수 있습니다. 이를 해결하기 위해 피보나치 수열을 계산하는 보다 효율적인 방법을 사용할 수 있습니다. 예를 들어, 행렬 제곱을 이용하면 시간 복잡도를 O(logn)으로 줄일 수 있습니다.

#### 행렬 제곱을 이용한 피보나치 수열 계산
피보나치 수열을 행렬 제곱을 이용해 계산하는 방법은 다음과 같습니다  
피보나치 수열은 다음과 같은 행렬을 이용해 계산할 수 있습니다  
[ f(n+1)  f(n) ]  =  [ 1  1 ] ^ n  
[ f(n)    f(n-1) ]  =  [ 1  0 ]

1. **행렬 곱셈 함수**: 두 행렬을 곱하고 결과를 반환합니다.
2. **행렬 거듭제곱 함수**: 행렬을 거듭제곱하여 피보나치 수열을 계산합니다. 재귀적으로 행렬을 제곱합니다.
3. **기본 행렬 설정**: 피보나치 수열을 계산하기 위한 기본 행렬 [11 / 10]을 설정합니다.
4. **피보나치 수 계산**: 행렬 거듭제곱을 사용하여 피보나치 수열의 n번째 값을 계산합니다.
이 접근 방식은 시간 복잡도가 O(log⁡n)O(\log n)O(logn)이므로, nnn이 매우 큰 경우에도 효율적으로 계산할 수 있습니다.
